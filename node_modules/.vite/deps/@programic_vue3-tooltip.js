import {
  Fragment,
  Teleport,
  createApp,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createTextVNode,
  defineComponent,
  h,
  inject,
  markRaw,
  mergeProps,
  openBlock,
  renderList,
  renderSlot,
  resolveDynamicComponent,
  toDisplayString,
  vShow,
  withDirectives,
  withModifiers
} from "./chunk-YYVLN2RI.js";
import "./chunk-HKJ2B2AA.js";

// node_modules/@programic/vue3-tooltip/dist/index.es.js
var q;
var It = new Uint8Array(16);
function zt() {
  if (!q && (q = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !q))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return q(It);
}
var m = [];
for (let t = 0; t < 256; ++t)
  m.push((t + 256).toString(16).slice(1));
function Wt(t, e = 0) {
  return (m[t[e + 0]] + m[t[e + 1]] + m[t[e + 2]] + m[t[e + 3]] + "-" + m[t[e + 4]] + m[t[e + 5]] + "-" + m[t[e + 6]] + m[t[e + 7]] + "-" + m[t[e + 8]] + m[t[e + 9]] + "-" + m[t[e + 10]] + m[t[e + 11]] + m[t[e + 12]] + m[t[e + 13]] + m[t[e + 14]] + m[t[e + 15]]).toLowerCase();
}
var jt = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var ut = {
  randomUUID: jt
};
function Ft(t, e, n) {
  if (ut.randomUUID && !e && !t)
    return ut.randomUUID();
  t = t || {};
  const o = t.random || (t.rng || zt)();
  if (o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, e) {
    n = n || 0;
    for (let i = 0; i < 16; ++i)
      e[n + i] = o[i];
    return e;
  }
  return Wt(o);
}
function H(t) {
  return t.split("-")[0];
}
function ot(t) {
  return t.split("-")[1];
}
function Z(t) {
  return ["top", "bottom"].includes(H(t)) ? "x" : "y";
}
function wt(t) {
  return t === "y" ? "height" : "width";
}
function dt(t, e, n) {
  let {
    reference: o,
    floating: i
  } = t;
  const c = o.x + o.width / 2 - i.width / 2, r = o.y + o.height / 2 - i.height / 2, l = Z(e), s = wt(l), a = o[s] / 2 - i[s] / 2, d = H(e), u = l === "x";
  let f;
  switch (d) {
    case "top":
      f = {
        x: c,
        y: o.y - i.height
      };
      break;
    case "bottom":
      f = {
        x: c,
        y: o.y + o.height
      };
      break;
    case "right":
      f = {
        x: o.x + o.width,
        y: r
      };
      break;
    case "left":
      f = {
        x: o.x - i.width,
        y: r
      };
      break;
    default:
      f = {
        x: o.x,
        y: o.y
      };
  }
  switch (ot(e)) {
    case "start":
      f[l] -= a * (n && u ? -1 : 1);
      break;
    case "end":
      f[l] += a * (n && u ? -1 : 1);
      break;
  }
  return f;
}
var Xt = async (t, e, n) => {
  const {
    placement: o = "bottom",
    strategy: i = "absolute",
    middleware: c = [],
    platform: r
  } = n, l = await (r.isRTL == null ? void 0 : r.isRTL(e));
  if (r == null && console.error(["Floating UI: `platform` property was not passed to config. If you", "want to use Floating UI on the web, install @floating-ui/dom", "instead of the /core package. Otherwise, you can create your own", "`platform`: https://floating-ui.com/docs/platform"].join(" ")), c.filter((g) => {
    let {
      name: p
    } = g;
    return p === "autoPlacement" || p === "flip";
  }).length > 1)
    throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement`", "middleware detected. This will lead to an infinite loop. Ensure only", "one of either has been passed to the `middleware` array."].join(" "));
  let s = await r.getElementRects({
    reference: t,
    floating: e,
    strategy: i
  }), {
    x: a,
    y: d
  } = dt(s, o, l), u = o, f = {}, h2 = 0;
  for (let g = 0; g < c.length; g++) {
    const {
      name: p,
      fn: b
    } = c[g], {
      x: y,
      y: x,
      data: O,
      reset: w
    } = await b({
      x: a,
      y: d,
      initialPlacement: o,
      placement: u,
      strategy: i,
      middlewareData: f,
      rects: s,
      platform: r,
      elements: {
        reference: t,
        floating: e
      }
    });
    if (a = y != null ? y : a, d = x != null ? x : d, f = {
      ...f,
      [p]: {
        ...f[p],
        ...O
      }
    }, h2 > 50 && console.warn(["Floating UI: The middleware lifecycle appears to be running in an", "infinite loop. This is usually caused by a `reset` continually", "being returned without a break condition."].join(" ")), w && h2 <= 50) {
      h2++, typeof w == "object" && (w.placement && (u = w.placement), w.rects && (s = w.rects === true ? await r.getElementRects({
        reference: t,
        floating: e,
        strategy: i
      }) : w.rects), {
        x: a,
        y: d
      } = dt(s, u, l)), g = -1;
      continue;
    }
  }
  return {
    x: a,
    y: d,
    placement: u,
    strategy: i,
    middlewareData: f
  };
};
function Yt(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function vt(t) {
  return typeof t != "number" ? Yt(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function F(t) {
  return {
    ...t,
    top: t.y,
    left: t.x,
    right: t.x + t.width,
    bottom: t.y + t.height
  };
}
async function qt(t, e) {
  var n;
  e === void 0 && (e = {});
  const {
    x: o,
    y: i,
    platform: c,
    rects: r,
    elements: l,
    strategy: s
  } = t, {
    boundary: a = "clippingAncestors",
    rootBoundary: d = "viewport",
    elementContext: u = "floating",
    altBoundary: f = false,
    padding: h2 = 0
  } = e, g = vt(h2), b = l[f ? u === "floating" ? "reference" : "floating" : u], y = F(await c.getClippingRect({
    element: (n = await (c.isElement == null ? void 0 : c.isElement(b))) == null || n ? b : b.contextElement || await (c.getDocumentElement == null ? void 0 : c.getDocumentElement(l.floating)),
    boundary: a,
    rootBoundary: d,
    strategy: s
  })), x = F(c.convertOffsetParentRelativeRectToViewportRelativeRect ? await c.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: u === "floating" ? {
      ...r.floating,
      x: o,
      y: i
    } : r.reference,
    offsetParent: await (c.getOffsetParent == null ? void 0 : c.getOffsetParent(l.floating)),
    strategy: s
  }) : r[u]);
  return {
    top: y.top - x.top + g.top,
    bottom: x.bottom - y.bottom + g.bottom,
    left: y.left - x.left + g.left,
    right: x.right - y.right + g.right
  };
}
var Gt = Math.min;
var Jt = Math.max;
var Kt = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function G(t) {
  return t.replace(/left|right|bottom|top/g, (e) => Kt[e]);
}
function Qt(t, e, n) {
  n === void 0 && (n = false);
  const o = ot(t), i = Z(t), c = wt(i);
  let r = i === "x" ? o === (n ? "end" : "start") ? "right" : "left" : o === "start" ? "bottom" : "top";
  return e.reference[c] > e.floating[c] && (r = G(r)), {
    main: r,
    cross: G(r)
  };
}
var Zt = {
  start: "end",
  end: "start"
};
function pt(t) {
  return t.replace(/start|end/g, (e) => Zt[e]);
}
function _t(t) {
  const e = G(t);
  return [pt(t), e, pt(e)];
}
var te = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(e) {
      var n;
      const {
        placement: o,
        middlewareData: i,
        rects: c,
        initialPlacement: r,
        platform: l,
        elements: s
      } = e, {
        mainAxis: a = true,
        crossAxis: d = true,
        fallbackPlacements: u,
        fallbackStrategy: f = "bestFit",
        flipAlignment: h2 = true,
        ...g
      } = t, p = H(o), y = u || (p === r || !h2 ? [G(r)] : _t(r)), x = [r, ...y], O = await qt(e, g), w = [];
      let k = ((n = i.flip) == null ? void 0 : n.overflows) || [];
      if (a && w.push(O[p]), d) {
        const {
          main: L,
          cross: N
        } = Qt(o, c, await (l.isRTL == null ? void 0 : l.isRTL(s.floating)));
        w.push(O[L], O[N]);
      }
      if (k = [...k, {
        placement: o,
        overflows: w
      }], !w.every((L) => L <= 0)) {
        var I, U;
        const L = ((I = (U = i.flip) == null ? void 0 : U.index) != null ? I : 0) + 1, N = x[L];
        if (N)
          return {
            data: {
              index: L,
              overflows: k
            },
            reset: {
              placement: N
            }
          };
        let v = "bottom";
        switch (f) {
          case "bestFit": {
            var z;
            const M = (z = k.map((D) => [D, D.overflows.filter((A) => A > 0).reduce((A, X) => A + X, 0)]).sort((D, A) => D[1] - A[1])[0]) == null ? void 0 : z[0].placement;
            M && (v = M);
            break;
          }
          case "initialPlacement":
            v = r;
            break;
        }
        if (o !== v)
          return {
            reset: {
              placement: v
            }
          };
      }
      return {};
    }
  };
};
async function ee(t, e) {
  const {
    placement: n,
    platform: o,
    elements: i
  } = t, c = await (o.isRTL == null ? void 0 : o.isRTL(i.floating)), r = H(n), l = ot(n), s = Z(n) === "x", a = ["left", "top"].includes(r) ? -1 : 1, d = c && s ? -1 : 1, u = typeof e == "function" ? e(t) : e;
  let {
    mainAxis: f,
    crossAxis: h2,
    alignmentAxis: g
  } = typeof u == "number" ? {
    mainAxis: u,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...u
  };
  return l && typeof g == "number" && (h2 = l === "end" ? g * -1 : g), s ? {
    x: h2 * d,
    y: f * a
  } : {
    x: f * a,
    y: h2 * d
  };
}
var ne = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(e) {
      const {
        x: n,
        y: o
      } = e, i = await ee(e, t);
      return {
        x: n + i.x,
        y: o + i.y,
        data: i
      };
    }
  };
};
var oe = function(t) {
  return t === void 0 && (t = {}), {
    name: "inline",
    options: t,
    async fn(e) {
      var n;
      const {
        placement: o,
        elements: i,
        rects: c,
        platform: r,
        strategy: l
      } = e, {
        padding: s = 2,
        x: a,
        y: d
      } = t, u = F(r.convertOffsetParentRelativeRectToViewportRelativeRect ? await r.convertOffsetParentRelativeRectToViewportRelativeRect({
        rect: c.reference,
        offsetParent: await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(i.floating)),
        strategy: l
      }) : c.reference), f = (n = await (r.getClientRects == null ? void 0 : r.getClientRects(i.reference))) != null ? n : [], h2 = vt(s);
      function g() {
        if (f.length === 2 && f[0].left > f[1].right && a != null && d != null) {
          var b;
          return (b = f.find((y) => a > y.left - h2.left && a < y.right + h2.right && d > y.top - h2.top && d < y.bottom + h2.bottom)) != null ? b : u;
        }
        if (f.length >= 2) {
          if (Z(o) === "x") {
            const v = f[0], M = f[f.length - 1], D = H(o) === "top", A = v.top, X = M.bottom, et = D ? v.left : M.left, it = D ? v.right : M.right, Ot = it - et, kt = X - A;
            return {
              top: A,
              bottom: X,
              left: et,
              right: it,
              width: Ot,
              height: kt,
              x: et,
              y: A
            };
          }
          const y = H(o) === "left", x = Jt(...f.map((v) => v.right)), O = Gt(...f.map((v) => v.left)), w = f.filter((v) => y ? v.left === O : v.right === x), k = w[0].top, I = w[w.length - 1].bottom, U = O, z = x, L = z - U, N = I - k;
          return {
            top: k,
            bottom: I,
            left: U,
            right: z,
            width: L,
            height: N,
            x: U,
            y: k
          };
        }
        return u;
      }
      const p = await r.getElementRects({
        reference: {
          getBoundingClientRect: g
        },
        floating: i.floating,
        strategy: l
      });
      return c.reference.x !== p.reference.x || c.reference.y !== p.reference.y || c.reference.width !== p.reference.width || c.reference.height !== p.reference.height ? {
        reset: {
          rects: p
        }
      } : {};
    }
  };
};
function bt(t) {
  return t && t.document && t.location && t.alert && t.setInterval;
}
function E(t) {
  if (t == null)
    return window;
  if (!bt(t)) {
    const e = t.ownerDocument;
    return e && e.defaultView || window;
  }
  return t;
}
function V(t) {
  return E(t).getComputedStyle(t);
}
function T(t) {
  return bt(t) ? "" : t ? (t.nodeName || "").toLowerCase() : "";
}
function xt() {
  const t = navigator.userAgentData;
  return t != null && t.brands ? t.brands.map((e) => e.brand + "/" + e.version).join(" ") : navigator.userAgent;
}
function R(t) {
  return t instanceof E(t).HTMLElement;
}
function $(t) {
  return t instanceof E(t).Element;
}
function ie(t) {
  return t instanceof E(t).Node;
}
function J(t) {
  if (typeof ShadowRoot > "u")
    return false;
  const e = E(t).ShadowRoot;
  return t instanceof e || t instanceof ShadowRoot;
}
function _(t) {
  const {
    overflow: e,
    overflowX: n,
    overflowY: o
  } = V(t);
  return /auto|scroll|overlay|hidden/.test(e + o + n);
}
function re(t) {
  return ["table", "td", "th"].includes(T(t));
}
function Rt(t) {
  const e = /firefox/i.test(xt()), n = V(t);
  return n.transform !== "none" || n.perspective !== "none" || n.contain === "paint" || ["transform", "perspective"].includes(n.willChange) || e && n.willChange === "filter" || e && (n.filter ? n.filter !== "none" : false);
}
function At() {
  return !/^((?!chrome|android).)*safari/i.test(xt());
}
var ht = Math.min;
var j = Math.max;
var K = Math.round;
function C(t, e, n) {
  var o, i, c, r;
  e === void 0 && (e = false), n === void 0 && (n = false);
  const l = t.getBoundingClientRect();
  let s = 1, a = 1;
  e && R(t) && (s = t.offsetWidth > 0 && K(l.width) / t.offsetWidth || 1, a = t.offsetHeight > 0 && K(l.height) / t.offsetHeight || 1);
  const d = $(t) ? E(t) : window, u = !At() && n, f = (l.left + (u && (o = (i = d.visualViewport) == null ? void 0 : i.offsetLeft) != null ? o : 0)) / s, h2 = (l.top + (u && (c = (r = d.visualViewport) == null ? void 0 : r.offsetTop) != null ? c : 0)) / a, g = l.width / s, p = l.height / a;
  return {
    width: g,
    height: p,
    top: h2,
    right: f + g,
    bottom: h2 + p,
    left: f,
    x: f,
    y: h2
  };
}
function S(t) {
  return ((ie(t) ? t.ownerDocument : t.document) || window.document).documentElement;
}
function tt(t) {
  return $(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.pageXOffset,
    scrollTop: t.pageYOffset
  };
}
function Tt(t) {
  return C(S(t)).left + tt(t).scrollLeft;
}
function le(t) {
  const e = C(t);
  return K(e.width) !== t.offsetWidth || K(e.height) !== t.offsetHeight;
}
function se(t, e, n) {
  const o = R(e), i = S(e), c = C(
    t,
    o && le(e),
    n === "fixed"
  );
  let r = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = {
    x: 0,
    y: 0
  };
  if (o || !o && n !== "fixed")
    if ((T(e) !== "body" || _(i)) && (r = tt(e)), R(e)) {
      const s = C(e, true);
      l.x = s.x + e.clientLeft, l.y = s.y + e.clientTop;
    } else
      i && (l.x = Tt(i));
  return {
    x: c.left + r.scrollLeft - l.x,
    y: c.top + r.scrollTop - l.y,
    width: c.width,
    height: c.height
  };
}
function Ct(t) {
  return T(t) === "html" ? t : t.assignedSlot || t.parentNode || (J(t) ? t.host : null) || S(t);
}
function gt(t) {
  return !R(t) || V(t).position === "fixed" ? null : t.offsetParent;
}
function ce(t) {
  let e = Ct(t);
  for (J(e) && (e = e.host); R(e) && !["html", "body"].includes(T(e)); ) {
    if (Rt(e))
      return e;
    {
      const n = e.parentNode;
      e = J(n) ? n.host : n;
    }
  }
  return null;
}
function nt(t) {
  const e = E(t);
  let n = gt(t);
  for (; n && re(n) && V(n).position === "static"; )
    n = gt(n);
  return n && (T(n) === "html" || T(n) === "body" && V(n).position === "static" && !Rt(n)) ? e : n || ce(t) || e;
}
function mt(t) {
  if (R(t))
    return {
      width: t.offsetWidth,
      height: t.offsetHeight
    };
  const e = C(t);
  return {
    width: e.width,
    height: e.height
  };
}
function ae(t) {
  let {
    rect: e,
    offsetParent: n,
    strategy: o
  } = t;
  const i = R(n), c = S(n);
  if (n === c)
    return e;
  let r = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = {
    x: 0,
    y: 0
  };
  if ((i || !i && o !== "fixed") && ((T(n) !== "body" || _(c)) && (r = tt(n)), R(n))) {
    const s = C(n, true);
    l.x = s.x + n.clientLeft, l.y = s.y + n.clientTop;
  }
  return {
    ...e,
    x: e.x - r.scrollLeft + l.x,
    y: e.y - r.scrollTop + l.y
  };
}
function fe(t, e) {
  const n = E(t), o = S(t), i = n.visualViewport;
  let c = o.clientWidth, r = o.clientHeight, l = 0, s = 0;
  if (i) {
    c = i.width, r = i.height;
    const a = At();
    (a || !a && e === "fixed") && (l = i.offsetLeft, s = i.offsetTop);
  }
  return {
    width: c,
    height: r,
    x: l,
    y: s
  };
}
function ue(t) {
  var e;
  const n = S(t), o = tt(t), i = (e = t.ownerDocument) == null ? void 0 : e.body, c = j(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), r = j(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0);
  let l = -o.scrollLeft + Tt(t);
  const s = -o.scrollTop;
  return V(i || n).direction === "rtl" && (l += j(n.clientWidth, i ? i.clientWidth : 0) - c), {
    width: c,
    height: r,
    x: l,
    y: s
  };
}
function Et(t) {
  const e = Ct(t);
  return ["html", "body", "#document"].includes(T(e)) ? t.ownerDocument.body : R(e) && _(e) ? e : Et(e);
}
function Q(t, e) {
  var n;
  e === void 0 && (e = []);
  const o = Et(t), i = o === ((n = t.ownerDocument) == null ? void 0 : n.body), c = E(o), r = i ? [c].concat(c.visualViewport || [], _(o) ? o : []) : o, l = e.concat(r);
  return i ? l : l.concat(Q(r));
}
function de(t, e) {
  const n = e.getRootNode == null ? void 0 : e.getRootNode();
  if (t.contains(e))
    return true;
  if (n && J(n)) {
    let o = e;
    do {
      if (o && t === o)
        return true;
      o = o.parentNode || o.host;
    } while (o);
  }
  return false;
}
function pe(t, e) {
  const n = C(t, false, e === "fixed"), o = n.top + t.clientTop, i = n.left + t.clientLeft;
  return {
    top: o,
    left: i,
    x: i,
    y: o,
    right: i + t.clientWidth,
    bottom: o + t.clientHeight,
    width: t.clientWidth,
    height: t.clientHeight
  };
}
function yt(t, e, n) {
  return e === "viewport" ? F(fe(t, n)) : $(e) ? pe(e, n) : F(ue(S(t)));
}
function he(t) {
  const e = Q(t), o = ["absolute", "fixed"].includes(V(t).position) && R(t) ? nt(t) : t;
  return $(o) ? e.filter((i) => $(i) && de(i, o) && T(i) !== "body") : [];
}
function ge(t) {
  let {
    element: e,
    boundary: n,
    rootBoundary: o,
    strategy: i
  } = t;
  const r = [...n === "clippingAncestors" ? he(e) : [].concat(n), o], l = r[0], s = r.reduce((a, d) => {
    const u = yt(e, d, i);
    return a.top = j(u.top, a.top), a.right = ht(u.right, a.right), a.bottom = ht(u.bottom, a.bottom), a.left = j(u.left, a.left), a;
  }, yt(e, l, i));
  return {
    width: s.right - s.left,
    height: s.bottom - s.top,
    x: s.left,
    y: s.top
  };
}
var me = {
  getClippingRect: ge,
  convertOffsetParentRelativeRectToViewportRelativeRect: ae,
  isElement: $,
  getDimensions: mt,
  getOffsetParent: nt,
  getDocumentElement: S,
  getElementRects: (t) => {
    let {
      reference: e,
      floating: n,
      strategy: o
    } = t;
    return {
      reference: se(e, nt(n), o),
      floating: {
        ...mt(n),
        x: 0,
        y: 0
      }
    };
  },
  getClientRects: (t) => Array.from(t.getClientRects()),
  isRTL: (t) => V(t).direction === "rtl"
};
function ye(t, e, n, o) {
  o === void 0 && (o = {});
  const {
    ancestorScroll: i = true,
    ancestorResize: c = true,
    elementResize: r = true,
    animationFrame: l = false
  } = o, s = i && !l, a = c && !l, d = s || a ? [...$(t) ? Q(t) : [], ...Q(e)] : [];
  d.forEach((p) => {
    s && p.addEventListener("scroll", n, {
      passive: true
    }), a && p.addEventListener("resize", n);
  });
  let u = null;
  if (r) {
    let p = true;
    u = new ResizeObserver(() => {
      p || n(), p = false;
    }), $(t) && !l && u.observe(t), u.observe(e);
  }
  let f, h2 = l ? C(t) : null;
  l && g();
  function g() {
    const p = C(t);
    h2 && (p.x !== h2.x || p.y !== h2.y || p.width !== h2.width || p.height !== h2.height) && n(), h2 = p, f = requestAnimationFrame(g);
  }
  return n(), () => {
    var p;
    d.forEach((b) => {
      s && b.removeEventListener("scroll", n), a && b.removeEventListener("resize", n);
    }), (p = u) == null || p.disconnect(), u = null, l && cancelAnimationFrame(f);
  };
}
var we = (t, e, n) => Xt(t, e, {
  platform: me,
  ...n
});
var ve = {
  id: {
    type: String,
    default: null
  },
  reference: {
    type: HTMLElement,
    default: null
  },
  trigger: {
    type: String,
    default: "hover"
  },
  placement: {
    type: String,
    default: null
  },
  size: {
    type: String,
    default: "small"
  },
  type: {
    type: String,
    default: "dark"
  },
  title: {
    type: String,
    required: true
  },
  description: {
    type: String,
    default: null
  },
  buttons: {
    type: Array,
    default: null
  },
  container: {
    type: Boolean,
    default: null
  }
};
var be = defineComponent({
  name: "Tooltip",
  props: ve,
  emits: [
    "close"
  ],
  data() {
    return {
      isOpen: false,
      options: inject("tooltipOptions", null),
      cleanupAutoUpdate: null
    };
  },
  computed: {
    defaultButtonType() {
      return this.type === "light" ? "primary" : "secondary";
    },
    disableTeleport() {
      var t;
      return ((t = this.options) == null ? void 0 : t.container) === false || this.container === false;
    },
    popperPlacement() {
      var t, e, n;
      return (n = (e = this.placement) != null ? e : (t = this.options) == null ? void 0 : t.placement) != null ? n : "top";
    }
  },
  beforeUnmount() {
    var t;
    (t = this.cleanupAutoUpdate) == null || t.call(this);
  },
  methods: {
    markRaw,
    initialize() {
      var n, o;
      const t = this.$refs.tooltip, e = (n = this.reference) != null ? n : this.$refs["tooltip-holder"];
      (o = this.cleanupAutoUpdate) == null || o.call(this), this.cleanupAutoUpdate = ye(e, t, async () => {
        const i = await we(e, t, {
          placement: this.popperPlacement,
          middleware: [
            te(),
            oe(),
            ne(() => ({
              mainAxis: 10
            }))
          ]
        });
        t.setAttribute("data-placement", i.placement), Object.assign(t.style, {
          left: "0",
          top: "0",
          transform: `translate(${Math.round(i.x)}px,${Math.round(i.y)}px)`
        });
      });
    },
    async buttonClick(t) {
      typeof t.onClick == "function" ? t.onClick() && this.$emit("close") : this.$emit("close");
    },
    open(t) {
      this.trigger === t && (this.isOpen = true, this.initialize());
    },
    close(t) {
      var e;
      this.trigger === t && ((e = this.cleanupAutoUpdate) == null || e.call(this), this.isOpen = false);
    },
    toggle(t) {
      if (this.isOpen) {
        this.close(t);
        return;
      }
      this.open(t);
    },
    click() {
      this.toggle("click");
    }
  }
});
var xe = (t, e) => {
  const n = t.__vccOpts || t;
  for (const [o, i] of e)
    n[o] = i;
  return n;
};
var Re = ["id", "data-type", "data-size"];
var Ae = { class: "tooltip-container" };
var Te = { class: "title" };
var Ce = ["innerHTML"];
var Ee = {
  key: 0,
  class: "mt-4 flex"
};
var Oe = ["data-type", "data-size", "onClick"];
function ke(t, e, n, o, i, c) {
  var r, l;
  return openBlock(), createElementBlock("span", null, [
    createBaseVNode("span", {
      onMouseenter: e[1] || (e[1] = withModifiers(() => t.open("hover"), ["prevent"])),
      onMouseleave: e[2] || (e[2] = withModifiers(() => t.close("hover"), ["prevent"]))
    }, [
      createBaseVNode("span", {
        ref: "tooltip-holder",
        class: "tooltip-holder",
        onClick: e[0] || (e[0] = (...s) => t.click && t.click(...s))
      }, [
        renderSlot(t.$slots, "default")
      ], 512)
    ], 32),
    (openBlock(), createBlock(Teleport, {
      disabled: t.disableTeleport,
      to: "#tooltip-container"
    }, [
      (r = t.options) != null && r.template ? withDirectives((openBlock(), createBlock(resolveDynamicComponent((l = t.options) == null ? void 0 : l.template), mergeProps({
        key: 0,
        ref: "tooltip"
      }, { ...t.$props, ...t.$attrs }), null, 16)), [
        [vShow, t.isOpen]
      ]) : withDirectives((openBlock(), createElementBlock("div", {
        key: 1,
        id: t.id,
        ref: "tooltip",
        "data-type": t.type,
        "data-size": t.size,
        class: "tooltip",
        style: { width: "fit-content" }
      }, [
        createBaseVNode("div", Ae, [
          createBaseVNode("div", null, [
            createBaseVNode("p", Te, [
              renderSlot(t.$slots, "title", {}, () => [
                createTextVNode(toDisplayString(t.title), 1)
              ])
            ]),
            renderSlot(t.$slots, "description", {}, () => [
              t.description ? (openBlock(), createElementBlock("p", {
                key: 0,
                class: "description",
                style: { "font-size": "calc(100% - .2rem)" },
                innerHTML: t.description
              }, null, 8, Ce)) : createCommentVNode("", true)
            ]),
            renderSlot(t.$slots, "actions", {}, () => [
              t.buttons && t.buttons.length > 0 ? (openBlock(), createElementBlock("div", Ee, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(t.buttons, (s, a) => {
                  var d, u;
                  return openBlock(), createElementBlock("button", {
                    key: `toast-button-${a}`,
                    "data-type": (d = s.type) != null ? d : t.defaultButtonType,
                    "data-size": (u = s.size) != null ? u : t.size,
                    class: "cursor-pointer mr-2",
                    onClick: (f) => t.buttonClick(s)
                  }, toDisplayString(s.title), 9, Oe);
                }), 128))
              ])) : createCommentVNode("", true)
            ])
          ])
        ])
      ], 8, Re)), [
        [vShow, t.isOpen]
      ])
    ], 8, ["disabled"]))
  ]);
}
var Le = xe(be, [["render", ke]]);
var Ve = {
  install: (t, e = {}) => {
    var o, i, c, r, l;
    if (typeof (e == null ? void 0 : e.container) == "object" && ((o = e == null ? void 0 : e.container) == null ? void 0 : o.enabled) !== false || (e == null ? void 0 : e.container) !== false) {
      let s = "tooltip-container", a = document.createElement("div");
      typeof (e == null ? void 0 : e.container) == "object" && typeof ((i = e == null ? void 0 : e.container) == null ? void 0 : i.ref) == "string" && (s = (c = e == null ? void 0 : e.container) == null ? void 0 : c.ref), a.setAttribute("id", s), typeof (e == null ? void 0 : e.container) == "object" && ((r = e == null ? void 0 : e.container) == null ? void 0 : r.ref) instanceof HTMLDivElement && (a = (l = e == null ? void 0 : e.container) == null ? void 0 : l.ref), document.body.append(a);
    }
    t.config.globalProperties.$tooltipOptions = e, t.provide("tooltipOptions", e);
    const n = {};
    t.directive("tooltip", {
      mounted(s, a, d) {
        const u = Ft(), f = h(Le, {
          id: u,
          title: a.value
        }, {
          default: () => d.children
        });
        s.dataset.tooltipId = u;
        const h2 = createApp(f);
        h2.mount(s), n[u] = h2;
      },
      unmounted(s) {
        var d;
        const a = s.dataset.tooltipId;
        a && ((d = n[a]) == null || d.unmount());
      }
    });
  }
};
export {
  Le as Tooltip,
  Ve as default
};
//# sourceMappingURL=@programic_vue3-tooltip.js.map
